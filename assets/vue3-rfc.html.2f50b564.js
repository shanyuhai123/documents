import{r as n,o as s,c as a,a as t,F as p,b as o,d as e}from"./app.ce027479.js";const c={},u=t("p",null,"个人认为在学 Vue3 前先来拜读一下 RFC 可能比较好，为什么要这么做？",-1),l=t("p",null,"我 Vue2 没有好好学，Vue3 也还没有开始看，信我你就错了。",-1),i={href:"https://composition-api.vuejs.org/zh/",target:"_blank",rel:"noopener noreferrer"},k=o("抄一遍原文"),r=o("。"),d=e('<h2 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h2><p>在此我们将为您介绍 Composition API：一组低侵入式的、函数式的 API，使得我们能够更灵活的「组合」组件的逻辑。</p><h2 id="基本范例" tabindex="-1"><a class="header-anchor" href="#基本范例" aria-hidden="true">#</a> 基本范例</h2><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    Count is: {{ state.count }},double is: {{ state.double }}\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span>\n  \n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    \n    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n    \n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">,</span>\n      increment\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><h2 id="动机与目的" tabindex="-1"><a class="header-anchor" href="#动机与目的" aria-hidden="true">#</a> 动机与目的</h2><h3 id="_1-更好的逻辑复用与代码组织" tabindex="-1"><a class="header-anchor" href="#_1-更好的逻辑复用与代码组织" aria-hidden="true">#</a> 1. 更好的逻辑复用与代码组织</h3><p>我们都因 Vue 简单易学而爱不释手，它让构建中小型应用程序变得轻而易举。但随着 Vue 的影响力日益扩大，许多用户也开始使用 Vue 构建更大型的项目。这些项目通常是由多个开发人员组成团队，在很长的一段时间内不断迭代和维护的。多年来，我们目睹了其中一些项目遇到 Vue 当前 API 所带来的编程模型的限制。这些问题可以归纳为两类：</p><ol><li>随着功能的增长，复杂组件的代码变得越来越难以阅读和理解。这种情况在开发人员阅读他人编写的代码时尤为常见。根本原因是 Vue 现有的 API 迫使我们通过选项组织代码，但是有时候通过逻辑关系组织代码更有意义。</li><li>目前缺少一种简洁且低成本的机制来提取和重用多个组件之间的逻辑。（详见<a href="#_3-%E9%80%BB%E8%BE%91%E6%8F%90%E5%8F%96%E4%B8%8E%E5%A4%8D%E7%94%A8">逻辑提取与复用</a>）</li></ol><p>RFC 中提出的 API 为组件代码的组织提供了更大的灵活性。现在我们不需要总是通过选项来组织代码，而是可以将代码组织为处理特定功能的函数。这些 API 还使得在组件之间甚至组件之外逻辑的提取和重用变得更加简单。我们会在<a href="#%E8%AE%BE%E8%AE%A1%E7%BB%86%E8%8A%82">设计细节</a>这一节展示达成的效果。</p><h3 id="_2-更好的类型推导" tabindex="-1"><a class="header-anchor" href="#_2-更好的类型推导" aria-hidden="true">#</a> 2. 更好的类型推导</h3><p>另一个来自大型项目开发者的常见需求是更好的 TypeScript 支持。Vue 当前的 API 在集成 TypeScript 时遇到了不小的麻烦，其主要原因是 Vue 依靠一个简单的 <code>this</code> 上下文来暴露 property，我们现在使用 <code>this</code> 的方式是比较微妙的。（比如 <code>methods</code> 选项下的函数的 <code>this</code> 是指向组件实例的，而不是这个 <code>methods</code> 对象）。</p><p>换句话说，Vue 现有的 API 在设计之初没有照顾到类型推导，这使适配 TypeScript 变得复杂。</p>',12),f=o("当前，大部分使用 TypeScript 的 Vue 开发者都在通过 "),g=t("code",null,"vue-class-component",-1),m=o(" 这个库将组件撰写为 TypeScript class（借助 decorator）。我们在设计 3.0 时曾有"),v={href:"https://github.com/vuejs/rfcs/pull/17",target:"_blank",rel:"noopener noreferrer"},h=o("一个已废弃的 RFC"),y=o("，希望提供一个内建的 Class API 来更好的解决类型问题。然而当时讨论并迭代具体设计时，我们注意到，想通过 Class API 来解决类型问题，就必须依赖 decorator -- 一个在实现细节上存在许多未知数的非常不稳定的 stage 2 提案。基于它是有极大风险的。（"),w=t("a",{href:"#_1-class-api-%E7%9A%84%E7%B1%BB%E5%9E%8B%E9%97%AE%E9%A2%98"},"关于 Class API 的类型相关问题请移步这里",-1),b=o("）"),x=e('<p>相比教过后，本 RFC 中提出的方案更多地利用了天然对类型友好的普通变量与函数。用该提案中的 API 撰写的代码会完美享用类型推导，并且也不用做太多额外的类型标注。</p><p>这也同样以为着你写出的 JavaScript 的代码几乎就是 TypeScript 代码。即使是非 TypeScript 开发者也会因此得到更好的 IDE 类型支持而获益。</p><h2 id="设计细节" tabindex="-1"><a class="header-anchor" href="#设计细节" aria-hidden="true">#</a> 设计细节</h2><h3 id="_1-api-介绍" tabindex="-1"><a class="header-anchor" href="#_1-api-介绍" aria-hidden="true">#</a> 1. API 介绍</h3><p>为了不引入全新的概念，该提案中的 API 更像是暴露 Vue 的核心功能 -- 比如用独立的函数来创建和监听响应式的状态等。</p><p>在这里我们会介绍一些最基本的 API，及如何取代 2.x 的选项表述组件内逻辑。</p><p>请注意，本节主要会介绍这些 API 的基本思路，所以不会展开至其完整的细节。完整的 API 规范请移步 API 参考章节。</p><h4 id="_1-1-响应式状态与副作用" tabindex="-1"><a class="header-anchor" href="#_1-1-响应式状态与副作用" aria-hidden="true">#</a> 1.1 响应式状态与副作用</h4><p>让我们从一个简单的任务开始：创建一个响应式的状态。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;vue&quot;</span>\n\n<span class="token comment">// state 现在是一个响应式的状态</span>\n<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">0</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p><code>reactive</code> 几乎等价于 2.x 中现有的 <code>Vue.observable()</code> API，且为了避免与 RxJS 中的 observable 混淆而做了重命名。这里返回的 <code>state</code> 是一个所有 Vue 用户都应该熟悉的响应式对象。</p><p>在 Vue 中，响应式状态的基本用例就是在渲染时使用它。因为有了依赖追踪，视图会在响应式状态发生改变时自动更新。在 DOM 当中渲染内容会被视为一种 “副作用”：程序会在外部修改其本身（也就是这个 DOM）的状态。我们可以使用 <code>watchEffect</code> API 应用基于响应式状态的副作用，并 <strong>自动</strong> 进行重新应用。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">count is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>state<span class="token punctuation">.</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p><code>watchEffect</code> 应该接收一个应用预期副作用（这里即设置 <code>innerHTML</code>）的函数。它会立即执行该函数，并将该执行过程中用到的所有响应式状态的 property 作为依赖进行追踪。</p><p>这里的 <code>state.count</code> 会在首次执行后作为依赖被追踪。当 <code>state.count</code> 未来发生变更时，里面这个函数又会被重新执行。</p><p>这正是 Vue 响应式系统的精髓所在了！当你在组件中从 <code>data()</code> 返回一个对象，内部实质上通过调用 <code>reactive()</code> 使其变为响应式。而模板会被编译为渲染函数（可被视为一种更高效的 <code>innerHTML</code>），因而可以使用这些响应式的 property。</p><blockquote><p><code>watchEffect</code> 和 2.x 中的 <code>watch</code> 选项类似，但是它不需要把被依赖的数据源和副作用回调分开。Composition API 同样提供了一个 <code>watch</code> 函数，其行为和 2.x 的选项完全一致。</p></blockquote><p>继续我们上面的例子，下面我们将展示如何处理用户输入：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n<span class="token punctuation">}</span>\n\ndocument<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;click&#39;</span><span class="token punctuation">,</span> increment<span class="token punctuation">)</span>\n</code></pre></div><p>但是在 Vue 的模板系统当中，我们不需要纠结用 <code>innerHTML</code> 还是手动挂载事件监听器。让我们将例子简化为一个假设的 <code>renderTemplate</code> 方法，以专注在响应性这方面：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">0</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">,</span>\n  increment<span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 假设的方法，并不是真实的 API</span>\n  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>\n    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;{{ state.count }}&lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    renderContext\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h4 id="_1-2-计算属性与-ref" tabindex="-1"><a class="header-anchor" href="#_1-2-计算属性与-ref" aria-hidden="true">#</a> 1.2 计算属性与 Ref</h4><p>有时候，我们会需要一个依赖于其他状态的状态，在 Vue 中这是通过计算属性来处理的。我们可以使用 <code>computed</code> API 直接创建一个计算值：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>\n</code></pre></div><p>这个 <code>computed</code> 返回了什么？如果猜一下 <code>computed</code> 内部是如何实现的，我们可能会想出下面这样的方案：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 简化的伪代码</span>\n<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> value\n  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    value <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token keyword">return</span> value\n<span class="token punctuation">}</span>\n</code></pre></div><p>但我们知道它不会正常工作：如果 <code>value</code> 是一个例如 <code>number</code> 的基础类型，那么当被返回时，它与这个 <code>computed</code> 内部之间的关系就丢失了！这是由于 JavaScript 中基础类型是值传递而非引用传递。</p><p>在把值作为 property 赋值给某个对象时也会出现同样的问题。一个响应式的值一旦作为 property 被赋值或从一个函数返回，而失去响应性之后，也就失去了用途。为了确保始终可以读取到最新的计算结果，我们需要将这个值包裹到一个对象中再返回。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 简化的伪代码</span>\n<span class="token keyword">function</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token parameter">getter</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> ref <span class="token operator">=</span> <span class="token punctuation">{</span>\n    value<span class="token operator">:</span> <span class="token keyword">null</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    ref<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">getter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  \n  <span class="token keyword">return</span> ref\n<span class="token punctuation">}</span>\n</code></pre></div><p>另外我们同样需要劫持这个对象 <code>.value</code> property 的读/写操作，来实现依赖收集与更新通知（为了简化我们忽略这里的代码实现）。</p><p>现在我们可以通过引用来传递计算值，也不需要担心其响应式特性会丢失了。当然代价就是：为了获取每次最新的值，我们每次都需要写 <code>.value</code>。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> double <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>double<span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// -&gt; 0</span>\n\nstate<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// -&gt; 2</span>\n</code></pre></div><p>在这里 <code>double</code> 是一个对象，我们管它叫 “ref”，用来作为一个响应式引用保留内部的值。</p><blockquote><p>你可能会担心 Vue 本身已经有 “ref” 的概念了。</p><p>但只是为了在模板中获取 DOM 元素或组件实例（“模板引用”）。可以前往 API 查看新的 ref 系统如何同时用于逻辑状态和模板引用。</p></blockquote><p>除了计算值的 ref，我们还可以使用 <code>ref</code> API 直接创建一个可变为普通的 ref：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>\n\ncount<span class="token punctuation">.</span>value<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre></div><h4 id="_1-3-解开-ref" tabindex="-1"><a class="header-anchor" href="#_1-3-解开-ref" aria-hidden="true">#</a> 1.3 解开 Ref</h4><p>我们可以将一个 ref 值暴露给渲染上下文，在渲染过程中，Vue 会直接使用其内部的值，也就是说在模板中你可以把：</p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n  <span class="token comment">&lt;!-- {{ count.value }} --&gt;</span>\n  <span class="token comment">&lt;!-- 直接替换为如下写法 --&gt;</span>\n  {{ count }}\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>这是计数器示例的另外一个版本，使用的是 <code>ref</code> 热不是 <code>reactive</code>：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  count<span class="token punctuation">.</span>value<span class="token operator">++</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token punctuation">{</span>\n  count<span class="token punctuation">,</span>\n  increment\n<span class="token punctuation">}</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>\n    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;{{ count }}&lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    renderContext\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>除此之外，当一个 ref 值嵌套于响应式对象之中时，访问时会自动解开：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n  double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 无需再使用 `state.double.value`</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>double<span class="token punctuation">)</span>\n</code></pre></div><h4 id="_1-4-组件中的使用方式" tabindex="-1"><a class="header-anchor" href="#_1-4-组件中的使用方式" aria-hidden="true">#</a> 1.4 组件中的使用方式</h4><p>到目前为止，我们的代码已经提供了一个可以根据用户输入进行更新的 UI，但是代码只运行了一次，无法重用。如果我们想重用其逻辑，那么不如重构成一个函数：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed<span class="token punctuation">,</span> watchEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    state<span class="token punctuation">,</span>\n    increment<span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> renderContext <span class="token operator">=</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">renderTemplate</span><span class="token punctuation">(</span>\n    <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;button @click=&quot;increment&quot;&gt;\n      Count is: {{ state.count }}, double is: {{ state.double }}\n    &lt;/button&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    renderContext\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><blockquote><p>请注意，上面的代码并不依赖于组件实例而存在。实际上，到目前为止介绍的所有 API 都可以在组件上下文之外使用，这使我们能够在更广泛的场景中利用 Vue 的响应性系统。</p></blockquote><p>现在如果我们把调用 <code>setup()</code>、创建侦听器和渲染模板的逻辑组合在一起交给框架，我们就可以仅通过 <code>setup()</code> 函数和模板定义一个组件：</p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>increment<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    Count is: {{ state.count }}, double is: {{ state.double }}\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive<span class="token punctuation">,</span> computed <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      count<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n      double<span class="token operator">:</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">,</span>\n      increment\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>这就是我们熟悉的单文件组件格式，只是逻辑的部分（<code>&lt;script&gt;</code>）格式表现稍有不同。模板语法与原先保持一致。<code>&lt;style&gt;</code> 这里被忽略了，因为它与原先并无二致。</p><h4 id="_1-5-生命周期钩子函数" tabindex="-1"><a class="header-anchor" href="#_1-5-生命周期钩子函数" aria-hidden="true">#</a> 1.5 生命周期钩子函数</h4><p>至此我们已经覆盖了组件的纯状态层面：响应式状态、计算状态和用户输入时的状态变更。但是一个组件可能还会产生其它副作用 -- 例如在控制台打印信息、发送 AJAX 请求或在全局 <code>window</code> 对象上设置事件监听器。这些副作用大多会发生在如下时间节点上：</p><ul><li>状态变化时；</li><li>组件挂载完成、内容更新或者解除挂载时（这就对应了生命周期钩子）。</li></ul><p>我们知道在状态变化时可以使用 <code>watchEffect</code> 和 <code>watch</code> API 应用副作用。而为了在生命周期钩子中产生副作用，我们可以使用形如 <code>onXXX</code> 的 API（对应现有的生命周期选项）。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;component is mounted!&#39;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这些生命周期注册方法只能用在 <code>setup</code> 钩子中。它会通过内部的全局状态自动找到调用此 <code>setup</code> 钩子的实例。有意如此设计是为了减少将逻辑提取到外部函数时的冲突。</p><blockquote><p>关于这些 API 的更多细节可以在 API 参考页面中找到。但是在深入挖掘设计细节之前，我们建议你先将接下来的章节看完。</p></blockquote><h3 id="_2-代码组织" tabindex="-1"><a class="header-anchor" href="#_2-代码组织" aria-hidden="true">#</a> 2. 代码组织</h3><p>此时我们已经将组件的 API 复制成了一些被导入的函数，但是这么做的目的是什么？用选项来定义组件看上去比用一个混入所有东西的大函数更具有组织性！</p><p>这种第一影响可以理解。但正如动机与目的章节提到的，我们相信 Composition API 实际上能够为你的代码带来更好的组织结构，尤其在复杂的组件中。下面我们将解释为什么。</p><h4 id="_2-1-什么是-有组织的代码" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是-有组织的代码" aria-hidden="true">#</a> 2.1 什么是 “有组织的代码”</h4>',61),A=o("有组织的代码的最终目标应该是让代码更可读、更容易被理解。那么怎么才叫 “理解” 代码呢？我们可以仅仅因为知道了它所包含的选项就算了解了一个组件么？你是否有接手过他人的庞大组件，比如"),P={href:"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404",target:"_blank",rel:"noopener noreferrer"},j=o("这个"),I=o("并觉得看得头晕？"),_=t("p",null,"想想我们该如何跟别的开发者同步理解上面链接里那样的一个大型组件。你大概会从 “这个组件在处理 X、Y 与 Z”开始，而不是 “这个组件有这些数据 property、这些计算属性和这些方法”。",-1),E=t("p",null,"当要去理解一个组件时，我们更加关心的是 “这个组件是要干什么”（即代码背后的意图），而不是 “这个组件用到了什么选项”。基于选项的 API 撰写出来的代码自然采用了后者的表述方式，然而对前者的表述并不好。",-1),S=t("h4",{id:"_2-2-逻辑关注点-vs-选项类型",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#_2-2-逻辑关注点-vs-选项类型","aria-hidden":"true"},"#"),o(" 2.2 逻辑关注点 vs. 选项类型")],-1),F=o("我们不妨将组件处理的 “X、Y 和 Z”定义为逻辑关注点。可读性的问题基本不会存在于小的、单一用途的组件中，因为整个组件都在处理同一个逻辑关注点。然而这个问题在复杂的用例中会变得突出。以 "),C={href:"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L198-L404",target:"_blank",rel:"noopener noreferrer"},V=o("Vue Cli UI 文件浏览器"),q=o("为例，这个组件有非常多的逻辑关注点："),M=t("ul",null,[t("li",null,"追踪监听当前文件夹的状态并展示其中的内容"),t("li",null,"处理文件夹的操作（打开、关闭、刷新…）"),t("li",null,"处理新建文件夹的创建"),t("li",null,"是否只展示收藏文件夹"),t("li",null,"是否只展示隐藏文件夹"),t("li",null,"处理当前工作目录的变化")],-1),R=t("p",null,"你能通过阅读基于选项的代码直接梳理出各个逻辑的关注点么？显然是非常困难的。你会发现到各个逻辑关注点相关的代码是分散在各处的。",-1),T=o("例如 “创建新文件夹” 的功能使用到了"),D={href:"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L221-L222",target:"_blank",rel:"noopener noreferrer"},L=o("两个数据 property"),B=o("、"),N={href:"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L240",target:"_blank",rel:"noopener noreferrer"},J=o("一个计算属性"),H=o("和"),X={href:"https://github.com/vuejs/vue-cli/blob/a09407dd5b9f18ace7501ddb603b95e31d6d93c0/packages/@vue/cli-ui/src/components/folder/FolderExplorer.vue#L387",target:"_blank",rel:"noopener noreferrer"},O=o("一个方法"),U=o("，而方法的定义在距离数据 property 约一百多行的位置。"),$=e('<p>如果我们对这些逻辑关注点进行染色，我们会注意到它们在用组件选项表示时是多么分散：</p><p><img src="https://user-images.githubusercontent.com/499550/62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2.png" alt="选项式代码"></p><p>正是这种碎片化使得理解和维护一个复杂的组件变得非常困难。选项的强行分离为展示背后的逻辑关注点设置了障碍。此外，在处理单个逻辑关注点时，我们必须不断地在选项代码块之间 “跳转”，以找到与该关注点相关的部分。</p><blockquote><p>注意：原始代码可能在某些地方有些改动，但是我们展示了在撰写文本时的最新提交，没有进行任何修改，目的就是为了提供一个我们自己编写生产环境代码的真实示例。</p></blockquote><p>如果我们能够将相同逻辑关注点的代码并列在一起，那就再好不过了。这正是 Composition API 所能做到的，“创建新文件夹” 功能可以这样写：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useCreateFloder</span><span class="token punctuation">(</span><span class="token parameter">openFolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token comment">// 原来的数据是 property</span>\n  <span class="token keyword">const</span> showNewFolder <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> newFolderName <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">&#39;&#39;</span><span class="token punctuation">)</span>\n  \n  <span class="token comment">// 原来的计算属性</span>\n  <span class="token keyword">const</span> newFolderValid <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">isValidMutiName</span><span class="token punctuation">(</span>newFolderName<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n  \n  <span class="token comment">// 原来的一个方法</span>\n  <span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">createFolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newFolderName<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token keyword">return</span>\n    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">mutate</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      mutation<span class="token operator">:</span> <span class="token constant">FOLDER_CREATE</span><span class="token punctuation">,</span>\n      varibles<span class="token operator">:</span> <span class="token punctuation">{</span>\n        name<span class="token operator">:</span> newFolderName<span class="token punctuation">.</span>value\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token function">openFolder</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>data<span class="token punctuation">.</span>folderCreate<span class="token punctuation">.</span>path<span class="token punctuation">)</span>\n    newFolderName<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token string">&#39;&#39;</span>\n    showNewFolder<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token boolean">false</span>\n  <span class="token punctuation">}</span>\n  \n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    showNewFolder<span class="token punctuation">,</span>\n    newFolderName<span class="token punctuation">,</span>\n    newFolderValid<span class="token punctuation">,</span>\n    createFolder\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>请注意，与创建新文件夹功能相关的逻辑现在都被合并并封装在了一个函数中。由于具有描述性的名称，该函数也是某种自文档。我们建议使用 <code>use</code> 作为函数名的开头，以表示它是一个组合函数。</p><p>此模式可用于该组件的所有其它逻辑关注点，最终成为一些良好解耦的函数：</p><p><img src="https://user-images.githubusercontent.com/499550/62783026-810e6180-ba89-11e9-8774-e7771c8095d6.png" alt="组合式代码"></p>',9),Y=o("这个比较不包括 import 语句和 "),Z=t("code",null,"setup()",-1),z=o(" 函数。使用复合 API 重新实现的完整组件可以在"),G={href:"https://gist.github.com/yyx990803/8854f8f6a97631576c14b63c8acd8f2e",target:"_blank",rel:"noopener noreferrer"},K=o("这里"),Q=o("找到。"),W=e('<p>每个逻辑关注点的代码现在都被整合进一个组合函数。这大大减少了在处理大型组件时不断 “跳转” 的需要。同时组合函数也可以在编辑器中折叠起来，使组件更容易浏览：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">useCurrentFolderData</span><span class="token punctuation">(</span><span class="token parameter">networkState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">useFolderNavigation</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> networkState<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">useFavouriteFolder</span><span class="token punctuation">(</span><span class="token parameter">currentFolderData</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">useHiddenFolders</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span><span class="token parameter">openFolder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><code>setup()</code> 现在只是简单地作为调用所有组合函数的入口：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 网络状态</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> networkState <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useNetworkState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    \n    <span class="token comment">// 文件夹状态</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> folders<span class="token punctuation">,</span> currentFolderData <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useCurrentFolderData</span><span class="token punctuation">(</span>networkState<span class="token punctuation">)</span>\n    <span class="token keyword">const</span> folderNavigation <span class="token operator">=</span> <span class="token function">useFolderNavigation</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      networkState<span class="token punctuation">,</span>\n      currentFolderData<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> favoriteFolders<span class="token punctuation">,</span> toggleFavorite <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFavoriteFolders</span><span class="token punctuation">(</span>\n      currentFolderData\n    <span class="token punctuation">)</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> showHiddenFolders <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useHiddenFolders</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> createFolder <span class="token operator">=</span> <span class="token function">useCreateFolder</span><span class="token punctuation">(</span>folderNavigation<span class="token punctuation">.</span>openFolder<span class="token punctuation">)</span>\n    \n    <span class="token comment">// 当前工作目录</span>\n    <span class="token function">resetCwdOnLeave</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> updateOnCwdChanged <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useCwdUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    \n    <span class="token comment">// 实用工具</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> slicePath <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">usePathUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    \n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      networkState<span class="token punctuation">,</span>\n      folders<span class="token punctuation">,</span>\n      currentFolderData<span class="token punctuation">,</span>\n      folderNavigation<span class="token punctuation">,</span>\n      favoriteFolders<span class="token punctuation">,</span>\n      toggleFavorite<span class="token punctuation">,</span>\n      showHiddenFolders<span class="token punctuation">,</span>\n      createFolder<span class="token punctuation">,</span>\n      updateOnCwdChanged<span class="token punctuation">,</span>\n      slicePath<span class="token punctuation">,</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>当然，使用选项 API 时我们不会这么写代码。但是请注意 <code>setup</code> 函数读起来几乎像是在口述这个组件尝试做什么 -- 这是基于选项的版本完全丢掉的信息。你还可以根据传递的参数清楚地看到组合函数之间的依赖关系。最后 return 语句作为单一出口确认暴露给模板的内容。</p><p>同样的功能，两套组件定义呈现出对内在逻辑的不同的表达方式。基于选项的 API 促使我们通过选项类型组织代码，而 Composition API 让我们可以基于逻辑关注点组织代码。</p><h3 id="_3-逻辑提取与复用" tabindex="-1"><a class="header-anchor" href="#_3-逻辑提取与复用" aria-hidden="true">#</a> 3. 逻辑提取与复用</h3><p>当我们在组件间提取并复用逻辑时，Composition API 是十分灵活的。一个组合函数仅依赖它的参数和 Vue 全局导出的 API，而不是依赖其微妙的 <code>this</code> 上下文。你可以将组件内的任何一段逻辑导出为函数以复用它。你甚至可以通过导出整个 <code>setup</code> 函数达到和 <code>extends</code> 等价的效果。</p><p>让我们来看看这个追踪鼠标位置的例子：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n  <span class="token keyword">const</span> y <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    x<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX\n    y<span class="token punctuation">.</span>value <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY\n  <span class="token punctuation">}</span>\n\n  <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;mousemove&#39;</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    window<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">&#39;mousemove&#39;</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>以下是一个组件如何利用该函数的展示：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useMousePosition <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;./mouse&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token comment">// 其他逻辑...</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>在 Composition API 版本的文件浏览器组件示例中，我们已经提取了很多工具代码（例如 <code>usePathUtils</code> 和 <code>useCwdUtils</code>）到外部文件中，因为我们发现它们也可以被用在其它组件中。</p><p>类似的逻辑复用也可以通过诸如 <code>mixins</code>、高阶组件或是（通过作用域插槽实现的）无渲染组件的模式达成。网上已经有很多解释这些模式的信息了，所以我们不再赘述。更高层的想法是，相比于组合函数，这些模式都有各自的弊端：</p><ul><li>渲染上下文中暴露的 property 来源不清晰。例如在阅读一个运用了多个 mixin 的模板时，很难看出某个 property 是从哪一个 mixin 中注入的。</li><li>命名空间冲突。Mixin 之间的 property 和方法可能有冲突，同时高阶组件也可能和预期的 prop 有命名冲突。</li><li>性能方面，高阶组件和无渲染组件需要额外的有状态的组件实例，从而使得性能有所损耗。</li></ul><p>相比而言，Composition API：</p><ul><li>暴露给模板的 property 来源十分清晰，因为它们都是被组合逻辑函数返回的值。</li><li>不存在命名空间冲突，可以通过解构任意命名。</li><li>不再需要仅为逻辑复用而创建的组件实例。</li></ul><h3 id="_4-与现有的-api-配合" tabindex="-1"><a class="header-anchor" href="#_4-与现有的-api-配合" aria-hidden="true">#</a> 4. 与现有的 API 配合</h3><p>Composition API 完全可以和现有的基于选项的 API 配合使用。</p><ul><li>Composition API 会在 2.x 的选项（<code>data</code>、<code>computed</code> 和 <code>methods</code>）之前解析，并且不能提前访问这些选项中定义的 property。</li><li><code>setup()</code> 函数返回的 property 将会被暴露给 <code>this</code>。它们在 2.x 的选项中可以访问到。</li></ul><h3 id="_5-插件开发" tabindex="-1"><a class="header-anchor" href="#_5-插件开发" aria-hidden="true">#</a> 5. 插件开发</h3><p>当下许多 Vue 插件都向 <code>this</code> 注入 property。例如 Vue Router 注入 <code>this.$route</code> 和 <code>this.$router</code>，而 Vuex 注入 <code>this.$store</code>。这使得类型推导变得很有技巧性，因为每个插件都要求用户为注入的 property 向 Vue 增加类型定义。</p><p>当使用 Composition API 时，我们不再使用 <code>this</code>，取而代之的是，插件将在内部利用 <code>provide</code> 和 <code>inject</code> 并暴露一个组合函数。以下是一个插件的假设代码：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> StoreSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">provideStore</span><span class="token punctuation">(</span><span class="token parameter">store</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">provide</span><span class="token punctuation">(</span>StoreSymbol<span class="token punctuation">,</span> store<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>StoreSymbol<span class="token punctuation">)</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 抛出错误，不提供 store</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> store\n<span class="token punctuation">}</span>\n</code></pre></div><p>消费者的代码：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 在根组件中提供 store</span>\n<span class="token comment">//</span>\n<span class="token keyword">const</span> App <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">provideStore</span><span class="token punctuation">(</span>store<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> Child <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token comment">// 使用 store</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre></div>',26),nn=o("注意这个 "),sn=t("code",null,"store",-1),an=o(" 也可以通过"),tn={href:"https://github.com/vuejs/rfcs/blob/master/active-rfcs/0009-global-api-change.md#provide--inject",target:"_blank",rel:"noopener noreferrer"},pn=o("全局 API 更改提案"),on=o("中 App 级别的 "),en=t("code",null,"provide",-1),cn=o(" 来提供，但是消费它的组件中的 "),un=t("code",null,"useStore",-1),ln=o(" 风格的 API 还是相同的。"),kn=e('<h2 id="弊端" tabindex="-1"><a class="header-anchor" href="#弊端" aria-hidden="true">#</a> 弊端</h2><h3 id="_1-引入-ref-的心智负担" tabindex="-1"><a class="header-anchor" href="#_1-引入-ref-的心智负担" aria-hidden="true">#</a> 1. 引入 Ref 的心智负担</h3><p>Ref 可以说是本提案中唯一的 “新” 概念。引入它是为了以变量形式传递响应式的值而不再依赖访问 <code>this</code>。其弊端如下：</p><ol><li><p>当使用组合式 API 时，我们需要一直区别「响应式值引用」与普通的基本类型值与对象，这无疑增加了使用本套 API 的心智负担。</p><p>这一层负担可以通过名称规范来大大降低（例如为所有的 ref 名加类似 <code>xxxRef</code> 的后缀），亦或是使用类型系统。另外，由于代码的组织方面的灵活性增加了，组件逻辑会更多地分解成一些短小精悍的函数，它们的上下文都比较简单，这些 ref 的上限也易于控制。</p></li><li><p>读写 ref 的操作比普通值的更冗余，因为需要访问 <code>.value</code>。</p><p>有人建议使用编译时的语法糖（类似 Svelte 3）来解决这个问题。这虽然在技术上可行，但我们并不认为 Vue 需要默认支持（正如在<a href="#_3-%E4%B8%8E-svelte-%E6%AF%94%E8%BE%83">与 Svelte 比较</a>中所讨论的那样）。换而言之，可以在用户端看开发一个 Babel 插件来处理。</p></li></ol><p>我们已经讨论过了是否可以完全避免引入 ref 的概念而只使用响应性对象，但是：</p><ul><li>计算值的 getter 可以返回基础类型值，所以类似 ref 的容器是不可避免的。</li><li>一些组合函数只接收或返回基础类型值，它们也需要被包裹成为一个对象才能够保持其响应性。如果框架不提供标准实现，那么用户最后会发明他们各自的 ref 模式（从而造成生态的碎片化）。</li></ul><h3 id="_2-ref-vs-reactive" tabindex="-1"><a class="header-anchor" href="#_2-ref-vs-reactive" aria-hidden="true">#</a> 2. Ref vs. Reactive</h3><p>可以理解的是，用户会纠结用 <code>ref</code> 还是 <code>reactive</code>。而首先你要知道的是，这两者你都必须了解，才能够高效地使用组合式 API。只用其中一个很可能会使你的工作无谓地复杂化，或反复地造轮子。</p><p>使用 <code>ref</code> 和 <code>reactive</code> 的区别，可以通过如何撰写标准的 JavaScript 逻辑来比较：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 风格 1：将变量分离</span>\n<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">0</span>\n<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">0</span>\n\n<span class="token keyword">function</span> <span class="token function">updatePosition</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX\n  y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY\n<span class="token punctuation">}</span>\n\n<span class="token comment">// --- 与下面的想比较 ---</span>\n\n<span class="token comment">// 风格 2：单个对象</span>\n<span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token punctuation">{</span>\n  x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n  y<span class="token operator">:</span> <span class="token number">0</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">updatePosition</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  pos<span class="token punctuation">.</span>x <span class="token operator">=</span> e<span class="token punctuation">.</span>pageX\n  pos<span class="token punctuation">.</span>y <span class="token operator">=</span> e<span class="token punctuation">.</span>pageY\n<span class="token punctuation">}</span>\n</code></pre></div><ul><li>如果使用 <code>ref</code>，我们实际上就是将 风格1 转换为使用 ref（为了让基础类型值具有响应性）的更细致的写法</li><li>使用 <code>reactive</code> 和 风格2 一致。我们只需要通过 <code>reactive</code> 创建这个对象。</li></ul><p>而只使用 <code>reactive</code> 的问题是，使用组合函数时必须始终保持对这个所返回对象的引用以保持响应性。这个对象不能被解构或展开：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 组合函数：</span>\n<span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n\t\tx<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    y<span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  \n  <span class="token keyword">return</span> pos\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 消费者组件</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n\t<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 这里会丢失响应性！</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y<span class="token punctuation">}</span>\n    \n    <span class="token comment">// 这里会丢失响应性！</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token operator">...</span><span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    \n    <span class="token comment">// 这是保持响应性的唯一办法！</span>\n    <span class="token comment">// 你必须返回 `pos` 本身，并按 `pos.x` 和 `pos.y` 的方式在模板中引用 x 和 y</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      pos<span class="token operator">:</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><code>toRefs</code> API 用来提供解决此约束的办法 -- 它将响应式对象的每个 property 都转成了相应的 ref。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> pos <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    x<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>\n    y<span class="token operator">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  \n  <span class="token keyword">return</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// x &amp; y 现在是 ref 形式了！</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useMousePosition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><p>总结一下，一共有两种变量风格：</p><ol><li>就像你在普通 JavaScript 中区别声明基础类型变量与对象变量时一样区别使用 <code>ref</code> 和 <code>reactive</code>。我们推荐你在此风格下结合 IDE 使用类型系统。</li><li>所有的地方都用 <code>reactive</code>，然后记得在组合函数返回响应式对象时使用 <code>toRefs</code>。这降低了一些关于 <code>ref</code> 的心智负担，但并不意味着你不需要熟悉这个概念。</li></ol><p>在这个阶段，我们认为现在就强制决定 <code>ref</code> vs. <code>reactive</code> 的最佳实践还为时过早。我们建议你对以上两种方式都进行尝试，选择与你心智模型更加配合的风格。我们将持续收集周边生态中的用户反馈，并最终在这个问题上提供更明确、更统一的实践指导建议。</p><h3 id="_3-返回语句冗长" tabindex="-1"><a class="header-anchor" href="#_3-返回语句冗长" aria-hidden="true">#</a> 3. 返回语句冗长</h3><p>一些用户会顾虑 <code>setup()</code> 的返回语句变得冗长，像是重复劳动。</p><p>我们相信明确的返回语句对可维护性是有益的。它使我们能够显式地控制暴露给模板的内容，并作为起点，追踪模板中某个 property 在组件哪里被定义的。</p><p>有些建议希望自动暴露 <code>setup()</code> 中声明的变量，使 <code>return</code> 语句变为可选的。再次重申，我们不认为这应该是默认的行为，因为它违背了标准 JavaScript 的直觉。不过还是有一些方法可以让用户侧的工作变少：</p><ul><li>开发 IDE 插件自动将 <code>setup()</code> 定义的变量插入到返回值语句中</li><li>开发 Babel 插件来隐式地生成并插入 <code>return</code> 语句</li></ul><h3 id="_4-更多的灵活性来自更多的自我克制" tabindex="-1"><a class="header-anchor" href="#_4-更多的灵活性来自更多的自我克制" aria-hidden="true">#</a> 4. 更多的灵活性来自更多的自我克制</h3><p>许多用户指出，虽然组合式 API 在代码组织方面提供了更多的灵活性，但它也需要开发者更多的自我克制来 “正确地完成它”。也有些人担心 API 会让没有经验的人编写出面条代码。换句话说，虽然组合式 API 提高了代码质量的上限，但也降低了下限。</p><p>我们在一定程度上同意这一点。但是，我们认为：</p><ol><li>提升上界的收益远远大于降低下界的损失。</li><li>通过适当的文档和社区指导，我们可以有效地解决代码组织问题。</li></ol><p>一些用户用 Angular 1 的控制器作为例子，来说明这种设计是如何导致糟糕代码的。组合式 API 和 Angular 1 控制器之间最大的不同是它不依赖于一个共享的作用域上下文。这使得将逻辑划分为单独的函数变得非常容易，这正是 JavaScript 代码组织的核心机制。</p><p>任何 JavaScript 程序都是从一个入口文件开始的（将它想象为程序的 <code>setup()</code>）。我们根据逻辑关注点将程序分解成函数和模块来组织它。组合式 API 使我们能够对 Vue 组件代码做同样的事情。换句话说，编写有组织的 JavaScript 代码的技能直接转化为了编写有组织的 Vue 代码的技能。</p><h2 id="接纳策略" tabindex="-1"><a class="header-anchor" href="#接纳策略" aria-hidden="true">#</a> 接纳策略</h2>',30),rn=o("组合式 API 完全是可被添加的，且不会影响/废弃任何现有的 2.x API。通过 "),dn=t("code",null,"@vue/composition",-1),fn=o(),gn={href:"https://github.com/vuejs/composition-api/",target:"_blank",rel:"noopener noreferrer"},mn=o("这个库"),vn=o("，它已经以插件的形式在 2.x 中生效了。这个库的基本宗旨就是提供一个机会让大家体验新的 API 并收集反馈。当前的实现已经与本提案的内容保持同步，但是由于插件的技术限制可能会包含一些微观的不一致。随着提案的更新，它也可能会做一些不兼容的变更，所以我们不建议这个阶段在生产环境中使用它。"),hn=e('<p>我们会将这一套 API 内建在 Vue 3.0 中，它将与现有的 2.x 选项同时可用。</p><p>对于想要在应用程序中仅使用组合式 API 的用户，我们可能会提供一个编译时标记来删除那些仅用于 2.x 选项的代码来减小整个库的大小，这是完全可选的。</p><p>这个 API 将被定位为高级特性，因为它旨在解决的问题主要出现在大型应用程序中。我们不打算彻底修改文档来把它用作默认方案。相反，它将在文档中有自己的专用部分。</p><h2 id="附录" tabindex="-1"><a class="header-anchor" href="#附录" aria-hidden="true">#</a> 附录</h2><h3 id="_1-class-api-的类型问题" tabindex="-1"><a class="header-anchor" href="#_1-class-api-的类型问题" aria-hidden="true">#</a> 1. Class API 的类型问题</h3><p>引入 Class API 的主要目的是提供另一种 API 以更好地支持 TypeScript 类型推导。但是，Vue 组件需要将声明自多个来源的 property 合并到一个 <code>this</code> 上下文中，这给基于 Class 的 API 带来了一些挑战。</p><p>Prop 的类型是其中一个例子。为了把 prop 合并到 <code>this</code> 中，我们不得不为组件的 Class 使用一个泛型参数，或使用一个 decorator。</p><p>这是用泛型参数的例子：</p><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">interface</span> <span class="token class-name">Props</span> <span class="token punctuation">{</span>\n  message<span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>\n  <span class="token keyword">static</span> props <span class="token operator">=</span> <span class="token punctuation">{</span>\n    messgae<span class="token operator">:</span> String\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>由于传递给泛型参数的 interface 仅仅是类型标注，所以用户仍然需要在 <code>this</code> 上为 prop 的代理行为提供其运行时声明。这种二次声明是多余且笨拙的。</p><p>使用 decorator 的例子如下：</p><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">Component<span class="token operator">&lt;</span>Props<span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>\n\t<span class="token decorator"><span class="token at operator">@</span><span class="token function">prop</span></span> message<span class="token operator">:</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>Decorators 存在如下问题：</p><ul><li>ES 的 decorator 提案仍然在 stage-2 且极其不稳定。过去一年内已经经历了两次彻底大改，且和 TS 现有的实现已经完全脱节。现在引入一个基于 TS decorator 实现的 API 风险太大。</li><li>Decorator 只能声明 class <code>this</code> 上的属性，却无法将某一类 decorator 声明的属性归并到一个对象上（比如 <code>$props</code>），这就导致 <code>this.$props</code> 无法被推导，且影响 TSX 的使用。</li><li>用户可能会觉得可以用 <code>@prop message: string = &#39;foo&#39;</code> 这样的写法去声明默认值，但事实上技术层面无法做到符合语义的实现。</li></ul><p>最后，class 还有一个问题，那就是目前 class method 不支持参数的 contextual typing，也就是说我们无法基于 class 本身的 fields 来推导某个 method 的参数类型，需要用户去声明。</p><h3 id="_2-与-react-hooks-的对比" tabindex="-1"><a class="header-anchor" href="#_2-与-react-hooks-的对比" aria-hidden="true">#</a> 2. 与 React Hooks 的对比</h3><p>这里提出的 API 和 React Hooks 有一定的相似性，具有同等的基于函数抽取和复用逻辑的能力，但也有很本质的区别。React Hooks 在每次组件渲染时都会调用，通过隐式地将状态挂载在当前的内部组件节点上，在下一次渲染时根据调用顺序取出。而 Vue 的 <code>setup()</code> 每个组件实例只会在初始化时调用一次，状态通过引用存储在 <code>setup()</code> 的闭包内。这意味着基于 Vue 的函数 API 的代码：</p><ul><li>整体上更符合 JavaScript 的直觉；</li><li>不受调用顺序的限制，可以有条件的被调用；</li><li>不会在后续更新时不断产生大量的内联函数而影响引擎优化或是导致 GC 压力；</li><li>不需要总是使用 <code>useCallback</code> 来缓存传给子组件的回调以防止过度更新；</li><li>不需要担心传了错误的依赖数组给 <code>useEffect/useMemo/useCallback</code> 从而导致回调中使用了过期的值 -- Vue 的依赖追踪是全自动的。</li></ul><blockquote><p>注：React Hooks 的开创性毋庸置疑，也是本提案的灵感来源。Hooks 代码和 JSX 并置使得对值的使用更简洁也是其优点，但其设计确实存在上述问题，而 Vue 的响应式系统恰巧能够让我们绕过这些问题。</p></blockquote><h3 id="_3-与-svelte-比较" tabindex="-1"><a class="header-anchor" href="#_3-与-svelte-比较" aria-hidden="true">#</a> 3. 与 Svelte 比较</h3><p>虽然采取了非常不同的方法，但是组合式 API 和 Svelte 3 基于编译思想的方法实际上在概念上有很多相似之处。这里有一个对比示例：</p><h4 id="_3-1-vue" tabindex="-1"><a class="header-anchor" href="#_3-1-vue" aria-hidden="true">#</a> 3.1 Vue</h4><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> watchEffect<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      count<span class="token punctuation">.</span>value<span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mounted!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      count<span class="token punctuation">,</span>\n      increment\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><h4 id="_3-2-svelte" tabindex="-1"><a class="header-anchor" href="#_3-2-svelte" aria-hidden="true">#</a> 3.2 Svelte</h4><div class="language-html ext-html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> <span class="token punctuation">{</span> onMount <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;svelte&#39;</span>\n  \n<span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  count<span class="token operator">++</span>\n<span class="token punctuation">}</span>\n  \n$<span class="token operator">:</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>\n\n<span class="token function">onMount</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mounted!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>Svelte 的代码看起来更简洁，因为它在编译时做了以下工作：</p><ul><li>隐式地将整个 <code>&lt;script&gt;</code> 块（import 语句除外）包装到一个函数中，该函数会被每个组件实例调用（而不是只执行一次）</li><li>隐式地为变量的变更注册响应性</li><li>隐式地向渲染上下文暴露所有作用域内的变量</li><li>将 <code>$</code> 语句编译为重复执行的代码</li></ul><p>从技术上讲，我们在 Vue 中也可以通过可能的 Babel 插件做到这些，但我们不想这样做的原因是：<strong>想要与标准 JavaScript 保持一致</strong>。如果要在 Vue 文件中提取 <code>&lt;script&gt;</code> 块的代码，我们希望它与标准的 ES 模块完全相同。Svelte 中 <code>&lt;script&gt;</code> 块的代码在技术上已经不再是标准的 JavaScript 了。我们觉得这种基于编译器的方法存在一些问题：</p>',28),yn=t("li",null,"在有或没有编译时，代码工作的方式不同。作为一个渐进的框架，许多 Vue 用户可能希望/需要/不得不在没有构建环节的情况下使用，因此编译的版本不会作为默认方案。另一方面，Svelte 将自己定位一种编译器且只用于构建环节。这是两个框架都在做的有意识的权衡。",-1),wn=o("代码在组件内部和外部的工作方式不同。当试图从一个 Svelte 的组件中提取逻辑并将其放入标准的 JavaScript 文件时，我们将失去那些神奇的语法糖，而不得不退回到"),bn={href:"https://svelte.dev/docs#svelte_store",target:"_blank",rel:"noopener noreferrer"},xn=o("更冗长的底层 API"),An=o("。"),Pn=o("Svelte 的响应性编译只适用于顶层变量 -- 它不触及函数内声明的变量，所以我们"),jn={href:"https://svelte.dev/repl/4b000d682c0548e79697ddffaeb757a3?version=3.6.2",target:"_blank",rel:"noopener noreferrer"},In=o("无法将响应式状态封装在一个函数中并声明在一个组件内"),_n=o("。这在通过函数来组织代码时带来了不小的约束，正如我们在这个提案中所演示的，这对于保持大型组件的可维护性非常重要。"),En={href:"https://github.com/sveltejs/svelte/issues/1639",target:"_blank",rel:"noopener noreferrer"},Sn=o("非标准语义使其与 TypeScript 的集成存在困难"),Fn=o("。"),Cn=t("p",null,"这并不是说 Svelte 3 不好 -- 事实上，它是一个非常创新的想法，并且我们高度尊重 Rich 的工作。但是基于 Vue 在设计上的克制及其目标，我们不得不做出不同的权衡。",-1);c.render=function(o,e){const c=n("OutboundLink");return s(),a(p,null,[t("blockquote",null,[u,l,t("p",null,[t("a",i,[k,t(c)]),r])]),d,t("p",null,[f,g,m,t("a",v,[h,t(c)]),y,w,b]),x,t("p",null,[A,t("a",P,[j,t(c)]),I]),_,E,S,t("p",null,[F,t("a",C,[V,t(c)]),q]),M,R,t("p",null,[T,t("a",D,[L,t(c)]),B,t("a",N,[J,t(c)]),H,t("a",X,[O,t(c)]),U]),$,t("blockquote",null,[t("p",null,[Y,Z,z,t("a",G,[K,t(c)]),Q])]),W,t("p",null,[nn,sn,an,t("a",tn,[pn,t(c)]),on,en,cn,un,ln]),kn,t("p",null,[rn,dn,fn,t("a",gn,[mn,t(c)]),vn]),hn,t("ol",null,[yn,t("li",null,[wn,t("a",bn,[xn,t(c)]),An]),t("li",null,[Pn,t("a",jn,[In,t(c)]),_n]),t("li",null,[t("a",En,[Sn,t(c)]),Fn])]),Cn],64)};export default c;
