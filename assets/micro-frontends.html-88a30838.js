import{_ as i,M as o,p as d,q as t,R as r,t as a,N as s,a1 as l}from"./framework-e3e34937.js";const h={},c={href:"https://micro-frontends.org/",target:"_blank",rel:"noopener noreferrer"};function f(m,e){const n=o("ExternalLinkIcon");return d(),t("div",null,[e[3]||(e[3]=r("h1",{id:"微前端",tabindex:"-1"},[r("a",{class:"header-anchor",href:"#微前端","aria-hidden":"true"},"#"),a(" 微前端")],-1)),r("p",null,[e[1]||(e[1]=a("随着前端业务场景越来越复杂，而")),r("a",c,[e[0]||(e[0]=a("微前端")),s(n)]),e[2]||(e[2]=a("这一概念则提供了一种解决方案。"))]),e[4]||(e[4]=l('<h2 id="iframe" tabindex="-1"><a class="header-anchor" href="#iframe" aria-hidden="true">#</a> iframe</h2><p><code>iframe</code> 彻底隔绝了应用间的上下文：</p><ul><li>父子之间的网页链接是不同的，浏览器一刷新，<code>iframe</code> 中的状态就没了，后退、前进按钮无法使用</li><li>父子之间的 UI 难以同步，内嵌的 <code>iframe</code> 并不会自动调节宽高，而且通信困难</li><li>全局上下文完全隔离，内存变量不共享，则需要完成 <code>iframe</code> 之间的通信及变量同步设计</li><li>慢，每次进子应用，浏览器都需要重新完整加载资源</li></ul><h2 id="方案" tabindex="-1"><a class="header-anchor" href="#方案" aria-hidden="true">#</a> 方案</h2><h3 id="qiankun" tabindex="-1"><a class="header-anchor" href="#qiankun" aria-hidden="true">#</a> qiankun</h3><h3 id="emp" tabindex="-1"><a class="header-anchor" href="#emp" aria-hidden="true">#</a> emp</h3>',6))])}const p=i(h,[["render",f],["__file","micro-frontends.html.vue"]]);export{p as default};
