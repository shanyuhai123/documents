import{d as n}from"./app.f66e5279.js";const s={},a=n('<h2 id="setup" tabindex="-1"><a class="header-anchor" href="#setup" aria-hidden="true">#</a> setup</h2><p><code>setup</code> 函数是一个新的组件选项。作为在组件内使用 Composition API 的入口点。</p><ul><li><p>调用时机</p><p>创建组件实例，然后初始化 <code>props</code>，紧接着就调用 <code>setup</code> 函数。从生命周期钩子的视角来看，它会在 <code>beforeCreate</code> 钩子之前被调用。</p></li><li><p>模板中使用</p><p>如果 <code>setup</code> 返回一个对象，则对象的属性将会被合并到组件模板的渲染上下文：</p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>\n    {{ count }} {{ object.foo }}\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n  \n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    \n    <span class="token comment">// 暴露给模板</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      count<span class="token punctuation">,</span>\n      object\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>注意 <code>setup</code> 返回的 ref 在模板中会自动解开，不需要写 <code>.value</code>。</p></li><li><p>渲染函数/JSX 中使用</p><p><code>setup</code> 也可以返回一个函数，函数中也能使用当前 <code>setup</code> 函数作用域中的响应式数据：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> h<span class="token punctuation">,</span> ref<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> object <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">&#39;bar&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    \n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">.</span>value<span class="token punctuation">,</span> object<span class="token punctuation">.</span>foo<span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li><li><p>参数</p><p>该函数接收 <code>props</code> 作为其第一个参数：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  props<span class="token operator">:</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span> String\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>注意 <code>props</code> 对象是响应式的，<code>watchEffect</code> 或 <code>watch</code> 会观察和响应 <code>props</code> 的更新：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  props<span class="token operator">:</span> <span class="token punctuation">{</span>\n\t\tname<span class="token operator">:</span> String\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">name is: </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span> props<span class="token punctuation">.</span>name<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>然而不要解构 <code>props</code> 对象，那样会使其失去响应性：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  props<span class="token operator">:</span> <span class="token punctuation">{</span>\n\t\tname<span class="token operator">:</span> String\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> name <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">name is: </span><span class="token template-punctuation string">`</span></span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token comment">// Will not be reactive!</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>在开发过程中，<code>props</code> 对象对用户空间代码是不可变的（用户代码尝试修改 <code>props</code> 时触发警告）。</p><p>第二个参数提供了一个上下文对象，从原来 2.x 中 <code>this</code> 选择性地暴露了一些 property。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> context</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    context<span class="token punctuation">.</span>attrs\n    context<span class="token punctuation">.</span>slots\n    context<span class="token punctuation">.</span>emit\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><code>attrs</code> 和 <code>slots</code> 都是内部组件实例上对应项的代理，可以确保在更新后仍然是最新值。所以可以被解构，无需担心后面访问到过期的值：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> <span class="token punctuation">{</span> attrs <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 一个可能之后回调用的签名</span>\n    <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>attrs<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 一定是最新的引用，没有丢失响应性</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>出于一些原因将 <code>props</code> 作为第一个参数，而不是包含在上下文中：</p><ul><li>组件使用 <code>props</code> 的场景更多，有时候甚至只使用 <code>props</code></li><li>将 <code>props</code> 独立出来作为第一个参数，可以让 TypeScript 对 <code>props</code> 单独做类型推导，不会和上下文中的其他属性想混淆。这也使得 <code>setup</code>、<code>render</code> 和其他使用了 TSX 的函数式组件的签名保持一致。</li></ul></li><li><p><code>this</code> 的用法</p><p><code>this</code> 在 <code>setup()</code> 中不可用。由于 <code>setup()</code> 在解析 2.x 选项前被调用，<code>setup()</code> 中的 <code>this</code> 将与 2.x 选项中的 <code>this</code> 完全不同。同时在 <code>setup()</code> 和 2.x 选项中使用 <code>this</code> 时将造成混乱。在 <code>setup()</code> 中避免这种情况的另一个原因是：这对于初学者来说，混淆这两种情况的 <code>this</code> 是非常常见的错误：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span> <span class="token comment">// 这里 `this` 与你期望的不一样！</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li><li><p>类型定义</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">interface</span> <span class="token class-name">Data</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span>key<span class="token operator">:</span> string<span class="token punctuation">]</span><span class="token operator">:</span> unknown\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">SetupContext</span> <span class="token punctuation">{</span>\n  attrs<span class="token operator">:</span> Data\n  slots<span class="token operator">:</span> Slots\n  <span class="token function-variable function">emit</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> string<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token operator">:</span> unknown<span class="token punctuation">[</span><span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> Data<span class="token punctuation">,</span> context<span class="token operator">:</span> SetupContext</span><span class="token punctuation">)</span><span class="token operator">:</span> Data\n</code></pre></div><div class="custom-container tip"><p class="custom-container-title">提示</p><p>为了获得传递给 <code>setup()</code> 参数的类型推断，需要使用 <code>defineComponent</code>。</p></div></li></ul><h2 id="响应式系统-api" tabindex="-1"><a class="header-anchor" href="#响应式系统-api" aria-hidden="true">#</a> 响应式系统 API</h2><h3 id="_1-reactive" tabindex="-1"><a class="header-anchor" href="#_1-reactive" aria-hidden="true">#</a> 1. reactive</h3><p>接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 <code>Vue.observable()</code>：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>响应式转换是 “深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象。</p><ul><li><p>类型定义</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> reactive<span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> <span class="token class-name">object</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>raw<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>\n</code></pre></div></li></ul><h3 id="_2-ref" tabindex="-1"><a class="header-anchor" href="#_2-ref" aria-hidden="true">#</a> 2. ref</h3><p>接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 <code>.value</code>。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>\n\ncount<span class="token punctuation">.</span>value<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre></div><p>如果传入 ref 的是一个对象，将调用 <code>reactive</code> 方法进行深层响应转换。</p><ul><li><p>模板中访问</p><p>当 ref 作为渲染上下文的属性返回（即在 <code>setup()</code> 返回的的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 <code>.value</code>：</p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      count<span class="token operator">:</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div></li><li><p>作为响应式对象的属性访问</p><p>当 ref 作为 reactive 对象的 property 被访问或修改时，也将自动解套 value 值，其行为类似普通属性：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 0</span>\n\nstate<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">1</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre></div><p>注意如果将一个新的 ref 分配给出现有 ref，将替换旧的 ref：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> otherCount <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n\nstate<span class="token punctuation">.</span>count <span class="token operator">=</span> otherCount\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 2</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 1</span>\n</code></pre></div><p>注意当嵌套在 reactive <code>Object</code> 中时，ref 才会解套。从 <code>Array</code> 或者 <code>Map</code> 等原生集合类中访问 ref 时，不会自动解套：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token comment">// 这里需要 .value</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">// 这里需要 .value</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n</code></pre></div></li><li><p>类型定义</p><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">interface</span> <span class="token class-name">Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>\n\tvalue<span class="token operator">:</span> <span class="token constant">T</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">ref</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>\n</code></pre></div><p>有时我们可能需要为 ref 做一个较为复杂的类型标注。我们可以通过在调用 <code>ref</code> 时传递泛型参数来覆盖默认推导：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> ref<span class="token operator">&lt;</span>string <span class="token operator">|</span> number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token comment">// foo 的类型: Ref&lt;string | number&gt;</span>\n\nfoo<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">123</span> <span class="token comment">// 能够通过！</span>\n</code></pre></div></li></ul><h3 id="_3-computed" tabindex="-1"><a class="header-anchor" href="#_3-computed" aria-hidden="true">#</a> 3. computed</h3><p>传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>plusOne<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 2</span>\n\nplusOne<span class="token punctuation">.</span>value<span class="token operator">++</span> <span class="token comment">// 错误！</span>\n</code></pre></div><p>或者传入一个拥有 <code>get</code> 和 <code>set</code> 函数的对象，创建一个可手动修改的计算状态。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> plusOne <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> count<span class="token punctuation">.</span>value <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    count<span class="token punctuation">.</span>value <span class="token operator">=</span> val <span class="token operator">-</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nplusOne<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">1</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 0</span>\n</code></pre></div><ul><li><p>类型定义</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 只读的</span>\n<span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token function-variable function">getter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Readonly<span class="token operator">&lt;</span>Ref<span class="token operator">&lt;</span>Readonly<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;&gt;</span>\n\n<span class="token comment">// 可更改的</span>\n<span class="token keyword">function</span> computed<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>options<span class="token operator">:</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span>\n  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>\n</code></pre></div></li></ul><h3 id="_4-readonly" tabindex="-1"><a class="header-anchor" href="#_4-readonly" aria-hidden="true">#</a> 4. readonly</h3><p>传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是 “深层” 的，对象内部任何嵌套的属性也都是只读的。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> original <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> copy <span class="token operator">=</span> <span class="token function">readonly</span><span class="token punctuation">(</span>original<span class="token punctuation">)</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 依赖追踪</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>copy<span class="token punctuation">.</span>count<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// original 上的修改会触发 copy 上的侦听</span>\noriginal<span class="token punctuation">.</span>count<span class="token operator">++</span>\n\n<span class="token comment">// 无法修改 copy 并会被警告</span>\ncopy<span class="token punctuation">.</span>count<span class="token operator">++</span> <span class="token comment">// warning!</span>\n</code></pre></div><h3 id="_5-watcheffect" tabindex="-1"><a class="header-anchor" href="#_5-watcheffect" aria-hidden="true">#</a> 5. watchEffect</h3><p>立即执行传入的一个函数，并响应式跟踪其依赖，并在其依赖变更时重新运行该函数。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">// -&gt; 0</span>\n\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  count<span class="token punctuation">.</span>value<span class="token operator">++</span>\n  <span class="token comment">// -&gt; 1</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>\n</code></pre></div><h4 id="_5-1-停止侦听" tabindex="-1"><a class="header-anchor" href="#_5-1-停止侦听" aria-hidden="true">#</a> 5.1 停止侦听</h4><p>当 <code>watchEffect</code> 在组件的 <code>setup()</code> 函数或生命周期钩子被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。</p><p>在一些情况下，也可以显式调用返回值以停止侦听：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> stop <span class="token operator">=</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* ... */</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 之后</span>\n<span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><h4 id="_5-2-清除副作用" tabindex="-1"><a class="header-anchor" href="#_5-2-清除副作用" aria-hidden="true">#</a> 5.2 清除副作用</h4><p>有时副作用函数会执行一些异步的副作用，这些响应需要在其失效时清除（即完成之前状态已改变了）。所以侦听副作用传入的函数可以接收一个 <code>onInvalidate</code> 函数作入参，用来注册清理失效时的回调。当以下情况发生时，这个失效回调会被触发：</p><ul><li>副作用即将重新执行时</li><li>侦听器被停止（如果在 <code>setup()</code> 或生命周期钩子中使用了 <code>watchEffect</code>，则在卸载组件时）</li></ul><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">onInvalidate</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> token <span class="token operator">=</span> <span class="token function">performAsyncOperation</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n  <span class="token function">onInvalidate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// id 改变时 或 停止侦听时</span>\n    <span class="token comment">// 取消之前的异步操作</span>\n    token<span class="token punctuation">.</span><span class="token function">cancel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>我们之所以是通过传入一个函数去注册失效回调，而不是从回调返回它（如 React <code>useEffect</code> 中的方式），是因为返回值对于异步错误处理很重要。</p><p>在执行数据请求时，副作用函数往往是一个异步函数：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  data<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetchData</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>我们知道异步函数都会隐式地返回一个 Promise，但是清理函数必须要在 Promise 被 resolve 之前被注册。另外，Vue 依赖这个返回的 Promise 来自动处理 Promise 链上的潜在错误。</p><h4 id="_5-3-副作用刷新时机" tabindex="-1"><a class="header-anchor" href="#_5-3-副作用刷新时机" aria-hidden="true">#</a> 5.3 副作用刷新时机</h4><p>Vue 的响应式系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个 tick 中多个状态改变导致不必要的重复调用，在核心的具体实现中，组件的更新函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时，会在所有的组件更新后执行：</p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{ count }}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n\n    <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      count\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>在这个例子中：</p><ul><li><code>count</code> 会在初始运行时同步打印出来</li><li>更改 <code>count</code> 时，将在组件更新后执行副作用</li></ul><p>请注意，初始化运行是在组件 <code>mounted</code> 之前执行的。因此，如果你希望在编写副作用函数时访问 DOM（或模板 ref），请在 <code>onMounted</code> 钩子中进行：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 在这里可以访问到 DOM 或者 template refs</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>如果副作用需要同步或在组件更新之前重新运行，我们可以传递一个拥有 <code>flush</code> 属性的对象作为选项（默认为 <code>&#39;post&#39;</code>）：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 同步执行</span>\n<span class="token function">watchEffect</span><span class="token punctuation">(</span>\n\t<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">//</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span>\n    flush<span class="token operator">:</span> <span class="token string">&#39;sync&#39;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span>\n\n<span class="token comment">// 组件更新前执行</span>\n<span class="token function">watchEffect</span><span class="token punctuation">(</span>\n\t<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">//</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span>\n    flush<span class="token operator">:</span> <span class="token string">&#39;pre&#39;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span>\n</code></pre></div><h4 id="_5-4-侦听器调试" tabindex="-1"><a class="header-anchor" href="#_5-4-侦听器调试" aria-hidden="true">#</a> 5.4 侦听器调试</h4><p><code>onTrack</code> 和 <code>onTrigger</code> 选项可用于调试一个侦听器的行为。</p><ul><li>当一个 reactive 对象熟悉或一个 ref 作为依赖被追踪时，将调用 <code>onTrack</code></li><li>依赖项变更导致副作用被触发时，将调用 <code>onTrigger</code></li></ul><p>这两个回调都将接收到一个包含有关依赖项信息的调试器事件。建议在以下回调中编写 <code>debugger</code> 语句来检查依赖关系：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token function">watchEffect</span><span class="token punctuation">(</span>\n  <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">/* 副作用的内容 */</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span>\n    <span class="token function">onTrigger</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">debugger</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span>\n</code></pre></div><p><code>onTrack</code> 和 <code>onTrigger</code> 仅在开发模式下生效。</p><h4 id="_5-5-类型定义" tabindex="-1"><a class="header-anchor" href="#_5-5-类型定义" aria-hidden="true">#</a> 5.5 类型定义</h4><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span>\n  <span class="token function-variable function">effect</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">onInvalidate<span class="token operator">:</span> InvalidateCbRegistrator</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>\n  options<span class="token operator">?</span><span class="token operator">:</span> WatchEffectOptions\n<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle\n\n<span class="token keyword">interface</span> <span class="token class-name">WatchEffectOptions</span> <span class="token punctuation">{</span>\n  flush<span class="token operator">?</span><span class="token operator">:</span> <span class="token string">&#39;pre&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;post&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;sync&#39;</span>\n  onTrack<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n  onTrigger<span class="token operator">?</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">event<span class="token operator">:</span> DebuggerEvent</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">DebuggerEvent</span> <span class="token punctuation">{</span>\n  effect<span class="token operator">:</span> ReactiveEffect\n  target<span class="token operator">:</span> any\n  type<span class="token operator">:</span> OperationTypes\n  key<span class="token operator">:</span> string <span class="token operator">|</span> symbol <span class="token operator">|</span> <span class="token keyword">undefined</span>\n<span class="token punctuation">}</span>\n\ntype <span class="token function-variable function">InvalidateCbRegistrator</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function-variable function">invalidate</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n\ntype <span class="token function-variable function">StopHandle</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n</code></pre></div><h3 id="_6-watch" tabindex="-1"><a class="header-anchor" href="#_6-watch" aria-hidden="true">#</a> 6. watch</h3><p><code>watch</code> API 完全等效于 2.x <code>this.$watch</code>（以及 <code>watch</code> 中相应的选项）。<code>watch</code> 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况是懒执行，也就是说仅在侦听的源变更时才执行回调。</p><p>对比 <code>watchEffect</code>，<code>watch</code> 允许我们：</p><ul><li>懒执行副作用</li><li>更明确哪些状态的改变会触发侦听器重新运行副作用</li><li>访问侦听状态变化前后的值</li></ul><h4 id="_6-1-侦听单个数据源" tabindex="-1"><a class="header-anchor" href="#_6-1-侦听单个数据源" aria-hidden="true">#</a> 6.1 侦听单个数据源</h4><p>侦听器的数据源可以是一个拥有返回值的 getter 函数，也可以是 ref：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 侦听一个 getter</span>\n<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> count<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token function">watch</span><span class="token punctuation">(</span>\n\t<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>count<span class="token punctuation">,</span>\n  <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">//</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span>\n\n<span class="token comment">// 侦听一个 ref</span>\n<span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>\n<span class="token function">watch</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">count<span class="token punctuation">,</span> prevCount</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">//</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h4 id="_6-2-侦听多个数据源" tabindex="-1"><a class="header-anchor" href="#_6-2-侦听多个数据源" aria-hidden="true">#</a> 6.2 侦听多个数据源</h4><p><code>watcher</code> 也可以使用数组来同时侦听多个源：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>fooRef<span class="token punctuation">,</span> barRef<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>prevFoo<span class="token punctuation">,</span> prevBar<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token comment">/* ... */</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h4 id="_6-3-与-watcheffect-共享的行为" tabindex="-1"><a class="header-anchor" href="#_6-3-与-watcheffect-共享的行为" aria-hidden="true">#</a> 6.3 与 watchEffect 共享的行为</h4><p>watch 和 watchEffect 在停止侦听，清除副作用、副作用刷新时机和侦听器调试等方面行为一致。</p><h4 id="_6-4-类型定义" tabindex="-1"><a class="header-anchor" href="#_6-4-类型定义" aria-hidden="true">#</a> 6.4 类型定义</h4><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token comment">// 侦听单数据源</span>\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">watch</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>\n\tsource<span class="token operator">:</span> WatcherSource<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>\n  \t<span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>\n   \toldValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>\n   \tonInvalidate<span class="token operator">:</span> InvalidateCbRegistrator</span>\n  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>\n  options<span class="token operator">?</span><span class="token operator">:</span> WatchOptions \n<span class="token punctuation">)</span><span class="token operator">:</span> StopHandle\n\n<span class="token comment">// 侦听多数据源</span>\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">watch</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span> <span class="token keyword">extends</span> WatcherSource<span class="token operator">&lt;</span><span class="token builtin">unknown</span><span class="token operator">&gt;</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>\n\tsources<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">callback</span><span class="token operator">:</span> <span class="token punctuation">(</span>\n  \t<span class="token parameter">values<span class="token operator">:</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n    oldValues<span class="token operator">:</span> MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>\n    onInvalidate<span class="token operator">:</span> InvalidateCbRegistrator</span>\n  <span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>\n  options<span class="token operator">?</span><span class="token operator">:</span> WatchOptions\n<span class="token punctuation">)</span><span class="token operator">:</span> StopHanle\n\n<span class="token keyword">type</span> <span class="token class-name">WatcherSource<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span><span class="token punctuation">)</span>\n\n<span class="token keyword">type</span> <span class="token class-name">MapSources<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token punctuation">[</span>k <span class="token keyword">in</span> <span class="token keyword">keyof</span> <span class="token constant">T</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">[</span><span class="token constant">K</span><span class="token punctuation">]</span> <span class="token keyword">extends</span> <span class="token class-name">WatcherSource<span class="token operator">&lt;</span><span class="token keyword">infer</span> <span class="token constant">V</span><span class="token operator">&gt;</span></span> <span class="token operator">?</span> <span class="token constant">V</span> <span class="token operator">:</span> <span class="token builtin">never</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 共有的属性 请查看 `watchEffect` 的类型定义</span>\n<span class="token keyword">interface</span> <span class="token class-name">WatchOptions</span> <span class="token keyword">extends</span> <span class="token class-name">WatchEffectOptions</span> <span class="token punctuation">{</span>\n  immediate<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span> <span class="token comment">// default: false</span>\n  deep<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">boolean</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="生命周期钩子函数" tabindex="-1"><a class="header-anchor" href="#生命周期钩子函数" aria-hidden="true">#</a> 生命周期钩子函数</h2><p>可以直接导入 <code>onXXX</code> 一族的函数来注册生命周期钩子：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> onMounted<span class="token punctuation">,</span> onUpdated<span class="token punctuation">,</span> onUnmounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> MyComponent <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mounted!&#39;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token function">onUpdated</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;updated!&#39;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token function">onUnmounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;unmounted!&#39;</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>这些生命周期钩子注册函数只能在 <code>setup()</code> 期间同步使用，因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 <code>setup()</code> 的组件实例），不再当前组件下调用这些函数会抛出一个错误。</p><p>组件实例上下文也是在生命周期钩子同步执行期间设置的，因此，在卸载组件时，在生命周期钩子内部同步创建的侦听器和计算状态也将自动删除。</p><h3 id="_1-与-2-x-版本生命周期对应的组合式-api" tabindex="-1"><a class="header-anchor" href="#_1-与-2-x-版本生命周期对应的组合式-api" aria-hidden="true">#</a> 1. 与 2.x 版本生命周期对应的组合式 API</h3><ul><li><s><code>beforeCreate</code></s> -&gt; 使用 <code>setup()</code></li><li><s><code>created</code></s> -&gt; 使用 <code>setup()</code></li><li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li><li><code>mounted</code> -&gt; <code>onMounted</code></li><li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li><li><code>updated</code> -&gt; <code>onUpdated</code></li><li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li><li><code>destroyed</code> -&gt; <code>onUnmounted</code></li><li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li></ul><h3 id="_2-新增的钩子函数" tabindex="-1"><a class="header-anchor" href="#_2-新增的钩子函数" aria-hidden="true">#</a> 2. 新增的钩子函数</h3><p>除了和 2.x 生命周期等效项之外，组合式 API 还提供了以下调试钩子函数：</p><ul><li><code>onRenderTracked</code></li><li><code>onRenderTriggered</code></li></ul><p>两个钩子函数都接收一个 <code>DebuggerEvent</code>，与 <code>watchEffect</code> 参数选项中的 <code>onTrack</code> 和 <code>onTrigger</code> 类似：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">onRenderTriggered</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">debugger</span>\n    <span class="token comment">// 检查哪个依赖性导致组件重新渲染</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入" aria-hidden="true">#</a> 依赖注入</h2><p><code>provide</code> 和 <code>inject</code> 提供依赖注入，功能类似 2.x 的 <code>provide/inject</code>。两者都只能在当前活动组件实例的 <code>setup()</code> 函数中调用。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> provide<span class="token punctuation">,</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> ThemeSymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> Ancestor <span class="token operator">=</span> <span class="token punctuation">{</span>\n\t<span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">&#39;dark&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> Descendent <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token string">&#39;light&#39;</span><span class="token punctuation">)</span>\n    \n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      theme\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p><code>inject</code> 接受一个可选的默认值作为第二个参数。如果未提供默认值，并且在 <code>provide</code> 上下文中未找到该属性，则 <code>inject</code> 返回 <code>undefined</code>。</p><h3 id="_1-注入的响应性" tabindex="-1"><a class="header-anchor" href="#_1-注入的响应性" aria-hidden="true">#</a> 1. 注入的响应性</h3><p>可以使用 <code>ref</code> 来保证 <code>provid</code> 和 <code>inject</code> 之间值的响应：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token comment">// 提供者：</span>\n<span class="token keyword">const</span> themeRef <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">&#39;dark&#39;</span><span class="token punctuation">)</span>\n<span class="token function">provide</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> themeRef<span class="token punctuation">)</span>\n\n<span class="token comment">// 使用者：</span>\n<span class="token keyword">const</span> theme <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>ThemeSymbol<span class="token punctuation">,</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token string">&#39;light&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">theme set to: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>theme<span class="token punctuation">.</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p>如果注入一个响应式对象，则它的状态变化也可以被侦听。</p><h3 id="_2-类型定义" tabindex="-1"><a class="header-anchor" href="#_2-类型定义" aria-hidden="true">#</a> 2. 类型定义</h3><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">interface</span> <span class="token class-name">InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">Symbol</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">provide</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span> value<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span>\n\n<span class="token comment">// 未传，使用缺省值</span>\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">inject</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>\n<span class="token comment">// 传入了默认值</span>\n<span class="token keyword">function</span> <span class="token generic-function"><span class="token function">inject</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>key<span class="token operator">:</span> InjectionKey<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">,</span> defaultValue<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span>\n</code></pre></div><p>Vue 提供了一个继承 <code>Symbol</code> 的 <code>InjectionKey</code> 接口。它可用于在提供者和消费者之间同步注入值的类型：</p><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> InjectionKey<span class="token punctuation">,</span> provide<span class="token punctuation">,</span> inject <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n\n<span class="token keyword">const</span> key<span class="token operator">:</span> InjecttionKey<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token function">provide</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token comment">// 类型不是 string 会报错</span>\n\n<span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">inject</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token comment">// foo 的类型：string | undefined</span>\n</code></pre></div><p>如果使用字符串作为键或没有定义类型的符号，则需要显式地声明注入值的类型：</p><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token generic-function"><span class="token function">inject</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span> <span class="token comment">// string | undefined</span>\n</code></pre></div><h2 id="模板-refs" tabindex="-1"><a class="header-anchor" href="#模板-refs" aria-hidden="true">#</a> 模板 Refs</h2><p>当使用组合式 API 时，reactive refs 和 template refs 的概念已经是统一的。为了获得对模板内元素或组件实例的引用，我们可以像往常一样在 <code>setup()</code> 中声明一个 ref 并返回它：</p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>root<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> onMounted <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n  \n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n    \n    <span class="token function">onMounted</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 在渲染完成后，这个 div DOM 会被赋值给 root ref 对象</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// &lt;div&gt;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    \n    <span class="token keyword">return</span> <span class="token punctuation">{</span> root <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>这里我们将 <code>root</code> 暴露在渲染上下文中，并通过 <code>ref=&quot;root&quot;</code> 绑定到 <code>div</code> 作为其 <code>ref</code>。在 Virtual DOM patch 算法中，如果一个 VNode 的 <code>ref</code> 对应一个渲染上下文中的 <code>ref</code>，则该 VNode 对应的元素或组件实例将被分配给该 ref。这是在 Virtual DOM 的 mount/patch 过程中执行的，因此模板 ref 仅在渲染初始化后才能访问。</p><p>ref 被用在模板中时和其他 ref 一样：都是响应式的，并可以传递进组合函数（或从其中返回）。</p><h3 id="_1-配合-render-jsx" tabindex="-1"><a class="header-anchor" href="#_1-配合-render-jsx" aria-hidden="true">#</a> 1. 配合 render/JSX</h3><div class="language-jsx ext-jsx"><pre class="language-jsx"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> root <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n    \n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span>\n    \t<span class="token string">&#39;div&#39;</span><span class="token punctuation">,</span>\n      <span class="token punctuation">{</span>\n        ref<span class="token operator">:</span> root\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">)</span>\n    \n    <span class="token comment">// JSX</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>root<span class="token punctuation">}</span></span> <span class="token punctuation">/&gt;</span></span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="_2-v-for-中使用" tabindex="-1"><a class="header-anchor" href="#_2-v-for-中使用" aria-hidden="true">#</a> 2. v-for 中使用</h3><p>模板 ref 在 <code>v-for</code> 中使用 vue 没有做特殊处理，需要使用函数型的 ref（3.0 提供的新功能）来自定义处理方式：</p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>(item, i) in list<span class="token punctuation">&quot;</span></span> <span class="token attr-name">:ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>el =&gt; { divs[i] = el }<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n    {{ item }}\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">import</span> <span class="token punctuation">{</span> ref<span class="token punctuation">,</span> reactive<span class="token punctuation">,</span> onBeforeUpdate <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>\n  \n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> divs <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n    \n    <span class="token comment">// 确保在每次变更之前重置引用</span>\n    <span class="token function">onBeforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n      divs<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      list<span class="token punctuation">,</span>\n      divs\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><h2 id="响应式系统工具集" tabindex="-1"><a class="header-anchor" href="#响应式系统工具集" aria-hidden="true">#</a> 响应式系统工具集</h2><h3 id="_1-unref" tabindex="-1"><a class="header-anchor" href="#_1-unref" aria-hidden="true">#</a> 1. unref</h3><p>如果参数是一个 ref 则返回它的 <code>value</code>，否则返回参数本身。它是 <code>value = isRef(val) ? val.value ? val</code> 的语法糖。</p><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token function">useFoo</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token operator">:</span> number <span class="token operator">|</span> Ref<span class="token operator">&lt;</span>number<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">const</span> unerapped <span class="token operator">=</span> <span class="token function">unref</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// unwrapped 一定是 number 类型</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="_2-toref" tabindex="-1"><a class="header-anchor" href="#_2-toref" aria-hidden="true">#</a> 2. toRef</h3><p><code>toRef</code> 可以用来为一个 reactive 对象的属性创建一个 ref。这个 ref 可以被传递并且能够保持响应性。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  bar<span class="token operator">:</span> <span class="token number">2</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> fooRef <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span>\n\nfooRef<span class="token punctuation">.</span>value<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 2</span>\n\nstate<span class="token punctuation">.</span>foo<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>fooRef<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 3</span>\n</code></pre></div><p>当您要将一个 prop 中的属性作为 ref 传递给组合逻辑函数时，<code>toRef</code> 就派上了用场：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">useSomeFeature</span><span class="token punctuation">(</span><span class="token function">toRef</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="_3-torefs" tabindex="-1"><a class="header-anchor" href="#_3-torefs" aria-hidden="true">#</a> 3. toRefs</h3><p>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref，和响应式对象 property 一一对应。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  bar<span class="token operator">:</span> <span class="token number">2</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> stateAsRefs <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>\n\n<span class="token comment">/*\nstateAsRefs 的类型如下:\n{\n  foo: Ref&lt;number&gt;,\n  bar: Ref&lt;number&gt;\n}\n*/</span>\n\n<span class="token comment">// ref 对象 与 原属性的引用是 &quot;链接&quot; 上的</span>\nstate<span class="token punctuation">.</span>foo<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>stateAsRefs<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 2</span>\n\nstateAsRefs<span class="token punctuation">.</span>foo<span class="token punctuation">.</span>value<span class="token operator">++</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>foo<span class="token punctuation">)</span> <span class="token comment">// 3</span>\n</code></pre></div><p>想要从一个组合逻辑函数中返回响应式对象时，用 <code>toRefs</code> 是很有效的，该 API 让消费者组件可以 解构/扩展（使用 <code>...</code> 操作符）返回的对象，并不会丢失响应性：</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n    bar<span class="token operator">:</span> <span class="token number">2</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  \n  <span class="token keyword">return</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 可以解构，且不会丢失响应性</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useFeatureX</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    \n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      foo<span class="token punctuation">,</span>\n      bar\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="_4-isref" tabindex="-1"><a class="header-anchor" href="#_4-isref" aria-hidden="true">#</a> 4. isRef</h3><p>检查一个值是否为一个 ref 对象。</p><h3 id="_5-isproxy" tabindex="-1"><a class="header-anchor" href="#_5-isproxy" aria-hidden="true">#</a> 5. isProxy</h3><p>检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理。</p><h3 id="_6-isreactive" tabindex="-1"><a class="header-anchor" href="#_6-isreactive" aria-hidden="true">#</a> 6. isReactive</h3><p>检查一个对象是否由 <code>reactive</code> 创建的响应式代理。</p><p>如果这个代理是由 <code>readonly</code> 创建的，但是又被 <code>reactive</code> 创建的另一个代理包裹了一层，那么同样也会返回 <code>true</code>。</p><h3 id="_7-isreadonly" tabindex="-1"><a class="header-anchor" href="#_7-isreadonly" aria-hidden="true">#</a> 7. isReadonly</h3><p>检查一个对象是否是由 <code>readonly</code> 创建的只读代理。</p><h2 id="高级响应式系统-api" tabindex="-1"><a class="header-anchor" href="#高级响应式系统-api" aria-hidden="true">#</a> 高级响应式系统 API</h2><h3 id="_1-customref" tabindex="-1"><a class="header-anchor" href="#_1-customref" aria-hidden="true">#</a> 1. customRef</h3><p><code>customRef</code> 用于自定义一个 <code>ref</code>，可以显式地控制以来追踪和触发响应，接受一个工厂函数，两个参数分别是用于追踪 <code>track</code> 与用于触发响应的 <code>trigger</code>，并返回一个带有 <code>get</code> 和 <code>set</code> 属性的对象。</p><ul><li><p>使用自定义 ref 实现带防抖功能的 <code>v-model</code></p><div class="language-vue ext-vue"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>\n\t<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>text<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>\n\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">\n<span class="token keyword">function</span> <span class="token function">useDebouncedRef</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">200</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> timeout\n  <span class="token keyword">return</span> <span class="token function">costomRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">track<span class="token punctuation">,</span> trigger</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">track</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token keyword">return</span> value\n      <span class="token punctuation">}</span><span class="token punctuation">,</span>\n      <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>\n        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n          value <span class="token operator">=</span> newValue\n          <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div></li><li><p>类型定义</p><div class="language-tsx ext-tsx"><pre class="language-tsx"><code><span class="token keyword">function</span> <span class="token generic-function"><span class="token function">customRef</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>factory<span class="token operator">:</span> CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Ref<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span>\n\n<span class="token keyword">type</span> <span class="token class-name">CustomRefFactory<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span> <span class="token punctuation">(</span>\n  <span class="token function-variable function">track</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>\n  <span class="token function-variable function">trigger</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">T</span>\n  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">value<span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span>\n<span class="token punctuation">}</span>\n</code></pre></div></li></ul><h3 id="_2-markraw" tabindex="-1"><a class="header-anchor" href="#_2-markraw" aria-hidden="true">#</a> 2. markRaw</h3><p>显式标记一个对象为 “永远不会转为响应式代理”，函数返回这个对象本身。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">markRaw</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isReactive</span><span class="token punctuation">(</span><span class="token function">reactive</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\n\n<span class="token comment">// 如果被 markRaw 标记了，即使在响应式对象中作属性，也依然不是响应式的</span>\n<span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> foo <span class="token punctuation">}</span><span class="token punctuation">)</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">isReactive</span><span class="token punctuation">(</span>bar<span class="token punctuation">.</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>\n</code></pre></div><h3 id="_3-shallowreactive" tabindex="-1"><a class="header-anchor" href="#_3-shallowreactive" aria-hidden="true">#</a> 3. shallowReactive</h3><p>只为某个对象的私有（第一层）属性创建浅层的响应式代理，不会对 “属性的属性” 做深层次、递归地响应式代理，而只是保留原样。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">shallowReactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  nested<span class="token operator">:</span> <span class="token punctuation">{</span>\n    bar<span class="token operator">:</span> <span class="token number">2</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 变更 state 的自有属性是响应式的</span>\nstate<span class="token punctuation">.</span>foo<span class="token operator">++</span>\n<span class="token comment">// ...但不会深层代理</span>\n<span class="token function">isReactive</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>nested<span class="token punctuation">)</span> <span class="token comment">// false</span>\nstate<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>bar<span class="token operator">++</span> <span class="token comment">// 非响应式</span>\n</code></pre></div><h3 id="_4-shallowreadonly" tabindex="-1"><a class="header-anchor" href="#_4-shallowreadonly" aria-hidden="true">#</a> 4. shallowReadonly</h3><p>只为某个对象的自有（第一层）属性创建浅层的<strong>只读</strong>响应式代理，同样也不会做深层次、递归地代理，深层次的属性并不是只读的。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">shallowReadonly</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  foo<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n  nested<span class="token operator">:</span> <span class="token punctuation">{</span>\n    bar<span class="token operator">:</span> <span class="token number">2</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 变更 state 的自有属性会失败</span>\nstate<span class="token punctuation">.</span>foo<span class="token operator">++</span>\n<span class="token comment">// ...但是嵌套的对象是可以变更的</span>\n<span class="token function">isReadonly</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>nested<span class="token punctuation">)</span> <span class="token comment">// false</span>\nstate<span class="token punctuation">.</span>nested<span class="token punctuation">.</span>bar<span class="token operator">++</span> <span class="token comment">// 嵌套属性依然可修改</span>\n</code></pre></div><h3 id="_5-shallowref" tabindex="-1"><a class="header-anchor" href="#_5-shallowref" aria-hidden="true">#</a> 5. shallowRef</h3><p>创建一个 ref，将会跟踪它的 <code>.value</code> 更改操作，但是并不会的对变更后的 <code>.value</code> 做响应式转换代理（即变更不会调用 <code>reactive</code>）。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token function">shallowRef</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 更改对操作会触发响应</span>\nfoo<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token comment">// 但上面新赋的这个对象并不会变为响应式对象</span>\n<span class="token function">isReactive</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// false</span>\n</code></pre></div><h3 id="_6-toraw" tabindex="-1"><a class="header-anchor" href="#_6-toraw" aria-hidden="true">#</a> 6. toRaw</h3><p>返回由 <code>reactive</code> 或 <code>readonly</code> 方法转换成响应式代理的普通对象。这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发更改。不建议一直持有原始对象的引用。请谨慎使用。</p><div class="language-javascript ext-js"><pre class="language-javascript"><code><span class="token keyword">const</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n<span class="token keyword">const</span> reactiveFoo <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">toRaw</span><span class="token punctuation">(</span>reactiveFoo<span class="token punctuation">)</span> <span class="token operator">===</span> foo<span class="token punctuation">)</span> <span class="token comment">// true</span>\n</code></pre></div>',147);s.render=function(n,s){return a};export default s;
