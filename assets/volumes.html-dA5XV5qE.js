import{_ as e,c as s,a as n,o as l}from"./app-BoSqM2g3.js";const t={};function c(o,a){return l(),s("div",null,[...a[0]||(a[0]=[n(`<h1 id="了解-docker-数据卷" tabindex="-1"><a class="header-anchor" href="#了解-docker-数据卷"><span>了解 Docker 数据卷</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><p>在生产环境中使用 Docker，往往需要对数据进行持久化，或者需要在多个容器之间进行数据共享。 容器中的数据管理方式有两种：</p><ol><li>数据卷（Data Volumes）：容器内数据直接映射到本地主机环境</li><li>数据卷容器（Data Volumes Containers）：使用特定容器维护数据卷</li></ol><h2 id="数据卷" tabindex="-1"><a class="header-anchor" href="#数据卷"><span>数据卷</span></a></h2><p>数据卷是一个可供容器使用的特殊目录，它将主机目录直接映射进容器，类似于 Linux 中的 mount 行为。 数据卷提供了一些特性：</p><ol><li>数据卷可以在容器之间共享和重用，容器间传递数据将变得高效与方便</li><li>对数据卷内数据的修改会立即生效，无论容器内操作还是主机操作</li><li>对数据卷的更新不会影响镜像，解耦开应用和数据</li><li>卷会一直存在，知道没有容器使用，可以安全地卸载它</li></ol><h3 id="_1-操作" tabindex="-1"><a class="header-anchor" href="#_1-操作"><span>1. 操作</span></a></h3><div class="language-bash" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 创建</span></span>
<span class="line"><span class="token comment"># docker volume create [OPTIONS] [VOLUME]</span></span>
<span class="line"><span class="token function">docker</span> volume create hello</span>
<span class="line"></span></code></pre></div><p>根据 <code>docker inspect hello</code> 可得知数据卷数据存放在 <code>/var/lib/docker/volumes/</code> 下。</p><h2 id="数据卷容器" tabindex="-1"><a class="header-anchor" href="#数据卷容器"><span>数据卷容器</span></a></h2><p>数据卷容器也是一个容器，但它的目的是专门提供数据卷给其他容器挂载。</p><div class="language-bash" data-highlighter="prismjs" data-ext="sh" data-title="sh"><pre><code><span class="line"><span class="token comment"># 创建数据卷容器</span></span>
<span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-v</span> /dbdata <span class="token parameter variable">--name</span> dbdata ubuntu</span>
<span class="line"></span>
<span class="line"><span class="token comment"># 接着可以在其他容器中挂载数据卷</span></span>
<span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> --volumes-from dbdata <span class="token parameter variable">--name</span> db1 ubuntu</span>
<span class="line"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> --volumes-from dbdata <span class="token parameter variable">--name</span> db2 ubuntu</span>
<span class="line"><span class="token comment"># 个人认为该形式并不好</span></span>
<span class="line"></span></code></pre></div><p>注意 <code>dbdata</code> 容器中使用了 <code>-v</code>，但其后仅跟随了 <code>/dbdata</code>，实际上会生成一个匿名的 volume，根据这个也可以推导出若跟随参数为 <code>hello/dbdata</code> 则会创建一个 <code>hello</code> volume，跳过先创建数据卷的步骤。</p><p>更进一步我们可以推导出 <code>-v</code> 无法指定去掉 <code>./</code> 的相对路径。</p>`,15)])])}const i=e(t,[["render",c]]),r=JSON.parse('{"path":"/backend/docker/volumes.html","title":"了解 Docker 数据卷","lang":"zh-CN","frontmatter":{"description":"了解 Docker 数据卷","autoPrev":"container"},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"数据卷","slug":"数据卷","link":"#数据卷","children":[{"level":3,"title":"1. 操作","slug":"_1-操作","link":"#_1-操作","children":[]}]},{"level":2,"title":"数据卷容器","slug":"数据卷容器","link":"#数据卷容器","children":[]}],"git":{"updatedTime":1636472013000,"contributors":[{"name":"shanyuhai123","username":"shanyuhai123","email":"864299347@qq.com","commits":5,"url":"https://github.com/shanyuhai123"}]},"filePathRelative":"backend/docker/volumes.md"}');export{i as comp,r as data};
