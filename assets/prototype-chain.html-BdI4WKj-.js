import{_ as s,c as a,a as t,o as p}from"./app-DNXRdI82.js";const o="/assets/prototype-chains-DEkyfqdn.jpg",e="/assets/prototype-chains-function-Cm8dcfuT.jpg",c={};function l(i,n){return p(),a("div",null,n[0]||(n[0]=[t(`<h1 id="原型链" tabindex="-1"><a class="header-anchor" href="#原型链"><span>原型链</span></a></h1><p>每一个 JavaScript 对象（null 除外）都和另一个对象相关联。“另一个” 对象即我们所熟知的原型，每一个对象都从原型继承属性。</p><p>所有通过对象直接量创建的对象都具有同一个原型对象，并可以通过 <code>Object.prototype</code> 获得对原型对象的引用。通过关键字 <code>new</code> 和构造函数调用创建的对象的原型就是构造函数的 prototype 属性的值。因此，同使用字面量创建对象一样，通过 <code>new Object</code> 创建的对象也继承自 <code>Object.prototype</code>。这一系列链接的原型对象就是所谓的 “原型链（prototype chain）”。</p><blockquote><p>可通过 <code>Object.getPrototypeOf()</code> 查询对象的原型。</p></blockquote><div class="hint-container caution"><p class="hint-container-title">提前的要点</p><ol><li><code>__proto__</code> 和 <code>constructor</code> 属性是对象所独有的</li><li><code>prototype</code> 属性是函数所独有的</li><li>但由于函数也是一种对象，所以函数也拥有 <code>__proto__</code> 和 <code>constructor</code> 属性</li></ol></div><h2 id="原型的继承" tabindex="-1"><a class="header-anchor" href="#原型的继承"><span>原型的继承</span></a></h2><p>对象除了 “自有属性（own property）”，还有一些属性是从原型对象继承来的。</p><p>属性访问细节：假设要查询对象 o 的属性 x，如果 o 中不存在 x，那么会继续在 o 的原型对象中查询属性 x。如果原型对象中也没有 x，但这个原型对象也有原型，那么继续在这个原型对象的原型上查询，直到找到 x 或者查找到一个原型是 null 的对象为止。由上可知，对象的原型属性构成了一个 “链”，通过这个 “链” 可以实现属性的继承。</p><blockquote><p>“继承” 意味着拷贝操作，而 JavaScript 补考呗对象属性。相反，JavaScript 在两个对象之间建立链接，一个对象实质上可以将对象、函数的访问 “委托” 到另一个对象上。</p></blockquote><h3 id="_1-小心继承" tabindex="-1"><a class="header-anchor" href="#_1-小心继承"><span>1. 小心继承</span></a></h3><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">var</span> anotherObject <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">2</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">var</span> myObject <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>anotherObject<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">anotherObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line">myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line"></span>
<span class="line">anotherObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line">myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span></span>
<span class="line"></span>
<span class="line">myObject<span class="token punctuation">.</span>a<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// oops, implicit shadowing!</span></span>
<span class="line"></span>
<span class="line">anotherObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 2</span></span>
<span class="line">myObject<span class="token punctuation">.</span>a<span class="token punctuation">;</span> <span class="token comment">// 3</span></span>
<span class="line"></span>
<span class="line">myObject<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p>虽然 <code>myObject.a++</code> 看起来应当通过委托查询并原地递增 <code>anotherObject.a</code> 的属性，但 <code>++</code> 操作符实际上等价于 <code>myObject.a = myObject.a + 1</code>，导致为 <code>myObject</code> 增加了 <code>a</code> 属性。</p><h2 id="关于链" tabindex="-1"><a class="header-anchor" href="#关于链"><span>关于链</span></a></h2><p>每个函数都有一个 <code>prototype</code> 属性，其指向一个对象，而这个对象就是函数（构造函数）创建的实例的原型；而每个对象都有一个 <code>__proto__</code> 属性，除了 null（虽然 <code>typeof null</code> 为 <code>object</code>，但这是一个错误结果），这个属性会指向该对象的原型：</p><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> f1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">f1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line">Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p>因为一个构造函数可以 <code>new</code> 出多个实例，很明显不存在原型指向实例，仅存在原型通过 <code>constructor</code> 指向构造函数：</p><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Foo<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p>在继承中了解到，查找属性时会顺着原型链一直找，直到 null。而原型也是个对象，那么它指向谁呢，可以利用 <code>Object</code> 创建最基础的对象：</p><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"><span class="token class-name">Foo</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token class-name">__proto__</span><span class="token punctuation">.</span>constructor <span class="token operator">===</span> Object<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p>而 <code>Object</code> 的原型往上则是 null 了，毕竟路是有“终点”的：</p><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p><img src="`+o+`" alt="prototype chains"></p><h3 id="_1-存在的问题" tabindex="-1"><a class="header-anchor" href="#_1-存在的问题"><span>1. 存在的问题</span></a></h3><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">Function <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line">Object <span class="token keyword">instanceof</span> <span class="token class-name">Function</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p>那究竟是谁在更上一层级呢？在规范中虽言及 ”函数是可调用的对象“，但个人认为它们是同时出现的：</p><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Function<span class="token punctuation">)</span> <span class="token operator">===</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p>更进一步：</p><div class="language-javascript" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line">Function<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line">Object<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line">Foo<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment">// true</span></span>
<span class="line"></span></code></pre></div><p><img src="`+e+'" alt="prototype chains function"></p>',29)]))}const r=s(c,[["render",l],["__file","prototype-chain.html.vue"]]),k=JSON.parse('{"path":"/frontend/javascript/prototype-chain.html","title":"原型链","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"原型的继承","slug":"原型的继承","link":"#原型的继承","children":[{"level":3,"title":"1. 小心继承","slug":"_1-小心继承","link":"#_1-小心继承","children":[]}]},{"level":2,"title":"关于链","slug":"关于链","link":"#关于链","children":[{"level":3,"title":"1. 存在的问题","slug":"_1-存在的问题","link":"#_1-存在的问题","children":[]}]}],"git":{"updatedTime":1637397829000,"contributors":[{"name":"shanyuhai123","username":"shanyuhai123","email":"864299347@qq.com","commits":6,"url":"https://github.com/shanyuhai123"}]},"filePathRelative":"frontend/javascript/prototype-chain.md"}');export{r as comp,k as data};
